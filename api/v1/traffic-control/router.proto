syntax = "proto3";

package trafficcontrol;

option go_package = "api/v1/trafficcontrol";
option java_package = "cn.polarismesh.polaris.trafficcontrol";

import "google/protobuf/wrappers.proto";
import "google/protobuf/any.proto";

// FlowStaining 流量染色
message FlowStaining {
  string id = 10;
  // flow statining rule name
  string name = 2;
  //
  repeated StaineRule rules = 3;
}

message StaineRule {
  // Traffic matching rules
  repeated SourceMatch arguments = 1;
  // Staining label
  repeated StaineLabel labels = 2;
  // Stain Label
  uint32 priority = 3;
  // rule is enabled
  bool enable = 4;
  // Set the percentage of traffic that needs to be dyed
  uint32 stainePercent = 5;
}

message StaineLabel {
  string Key = 1;
  string Value = 2;
}

enum RoutingPolicy {
  // Route by rule rule => RuleRoutingConfig
  RulePolicy = 0;
  // Route by destination metadata
  MetadataPolicy = 1;
}

// configuration root for route
message Routing {
  string id = 1;
  // route rule name
  string name = 2;
  // namespace 路由规则所属的命名空间
  string namespace = 3;
  // Enable this router
  google.protobuf.BoolValue enable = 4;
  // Router type
  RoutingPolicy routing_policy = 5;
  // Routing configuration for router
  google.protobuf.Any routing_config = 6;
  // revision 当前路由规则的版本信息
  string revision = 7;
}

message MetadataFailover {
  enum FailoverRange {
    // ALL 直接返回全部实例
    ALL = 0;
    // OTHERS 返回没有这些标签的实例
    OTHERS = 1;
    // OTHER_KEYS 根据另外一组标签进行筛选
    OTHER_KEYS = 2;
  }
  // 元数据路由兜底类型
  FailoverRange failover_range = 1;
  // 仅仅用于 failover_range == OTHER_KEYS 时生效
  map<string, string> labels = 2;
}

// MetadataRoutingConfig 元数据路由配置
message MetadataRoutingConfig {
  map<string, string> labels = 1;
  // When metadata not found, it will fall back to the
  MetadataFailover failover = 2;
}

// RuleRoutingConfig 规则路由配置
message RuleRoutingConfig {
  // If you match the Source rule, follow the Destination route
  // The relationship between multiple SOURCE is or
  Source source = 1;
  //
  Destination destination = 2;
}

message Source {
  // Main tuning service and namespace
  string service = 1;
  string namespace = 2;

  // Master Control Service Example Tag or Request Label
  // Value supports regular matching
  repeated SourceMatch arguments = 3;
}

message Destination {
  // Templated service and namespace
  string service = 1;
  string namespace = 2;

  // Templated service example label
  // Value supports regular matching
  map<string, string> labels = 3;

  // According to the service name and service instance Metadata Filter the
  // qualified service instance subset Service instance subset can set priority
  // and weight Priority: integer, range [0, 9], the highest priority is 0
  // Weight: Integer
  // Press priority routing, if there is high priority, low priority will not
  // use If there is a subset of the same priority, then assign by weight
  // Priority and weight can be not set / set up one / set two
  // If the section is set priority, some are not set, it is considered that the
  // priority is not set. If the part is set, some is not set, it is considered
  // that the weight is not set to 0 If you have no weight, you think the weight
  // is the same
  uint32 priority = 4;
  uint32 weight = 5;

  // Forward requests to proxy service
  string transfer = 6;

  // Whether to isolate the SET, after isolation, no traffic will be allocated
  bool isolate = 7;
}

// MatchString
message MatchString {
  enum MatchStringType {
    // Equivalent match
    EQUALS = 0;
    // Not equals match
    NOT_EQUALS = 1;
    // Include match
    INCLUDE = 2;
    // Not include match
    NOT_INCLUDE = 3;
    // Less than match
    LESS_THAN = 4;
    // Greater than match
    GREATER_THAN = 5;
    // Regular match
    REGEX = 6;
  }

  enum ValueType {
    // Routing rules write dead data
    TEXT = 0;
  }
  // Matching rule
  MatchStringType type = 1;
  // Routing rules
  string value = 2;
  // Value type, specific acquisition path for routing rule values
  ValueType value_type = 3;
}

message SourceMatch {
  // label type for gateway request
  enum Type {
    // custom arguments
    CUSTOM = 0;
    // method, match the http post/get/put/delete or grpc method
    METHOD = 1;
    // header, match the http header, dubbo attachment, grpc header
    HEADER = 2;
    // query, match the http query, dubbo argument
    QUERY = 3;
    // caller host ip
    CALLER_IP = 4;
  }
  Type type = 1;
  // header key or query key
  string key = 2;
  // header value or query value
  MatchString value = 3;
}
